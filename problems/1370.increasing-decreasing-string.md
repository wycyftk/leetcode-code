### 题目

1370. 上升下降字符串
给你一个字符串 s ，请你根据下面的算法重新构造字符串：

从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 s 中字符重新排序后的 结果字符串 。

### 解法一-字母数组

这里使用了数组记录字母的出现次数，数组的长度是固定的26，下标分别对应26个字母。如果a出现3次，那么 `arr[0]` 就是 3。然后通过来回遍历，每次遍历的时候就将数字减少1，将计算出的字母添加到结果 `r` 的后面。

```python3
class Solution:  
    def sortString(self, s: str) -> str:
        ACHARCODE = ord('a')
        arr = [0] * 26
        flag = True
        r = ''
        for i in s:
            arr[ord(i) - ACHARCODE] += 1

        while flag:
            flag = False
            for n in range(26):
                if arr[n] > 0:
                    r += chr(ACHARCODE + n)
                    arr[n] -= 1
                flag = flag or arr[n] > 0

            for n in range(25, -1, -1):
                if arr[n] > 0:
                    r += chr(ACHARCODE + n)
                    arr[n] -= 1
                flag = flag or arr[n] > 0
        return r
```
时间复杂度：O(N)，因为数组的长度固定是26，假如字符都是同一个字母，这时时间复杂度最高，为 N * 26 。26是常数，可以去掉，所以简化成 O(N)
空间复杂度：O(1)，数组的长度是固定的，不会变化，所以是 O(1) 的复杂度
