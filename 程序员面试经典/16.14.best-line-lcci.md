### 题目

面试题 16.14. 最佳直线

给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。

设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。

### 思路

题目要求直线穿过的点最多，那问题就在于如何确定这些点在一条线上。根据直线公式 `y(x) = kx + d` 可知，当斜率k与纵坐标偏移量都相等的时候，两个点就在一条直线上。直接求k和d，未免复杂了一点。如果我们以一个点为起点，与其他点连线，由于起点是固定的，所以有另外两个点与这个点的连线的斜率相等时，它们就在一条线上。证明如下：

假设两个点的坐标分别为(x1, y1) (x2, y2)，那么 y2 - y1 = (kx2 + d) - (kx1 + d)，那么 k = (y2 - y1) / (x2 - x1)

所以以一个点为起点的时候，且k相等的时候，这些点就在一条线上。我们将斜率k和这个点在数组里的下标存在字典里，就可以得到结果了。有一个需要考虑的特殊情况，就是斜率为0，会导致计算出错。

之后就是对求出的下标的处理，因为每次的起点会变，起点的下标加入了数组后，数组会变得无序。所以需要对它们进行排序处理。其他的就是根据题目要求，处理S[0] S[1] 相等的情况。

### 哈希法

```python3
class Solution:
    def bestLine(self, points: List[List[int]]) -> List[int]:
        m = {}
        res = []
        l = 0

        for i in range(len(points)):
            for j in range(len(points)):
                if i == j:
                    continue

                dx = points[i][0] - points[j][0]
                dy = points[i][1] - points[j][1]

                if dx == 0:
                    m['0'] = m.get('0', [i]) + [j]
                else:
                    k = dy / dx
                    m[k] = m.get(k, [i]) + [j]
            
            for v in m.values():
                if len(v) > l:
                    res = sorted(v)[0:2] # 数组不一定有序，需要进行排序
                    l = len(v)
                elif len(v) == l:
                    t = sorted(v)[0:2]
                    if t[0] < res[0]:
                        res = t
                    elif t[0] == res[0] and t[1] < res[1]:
                        res = t
            m.clear()
        return res
```
时间复杂度：O(N^2 * logN)。N是数组的长度，两层循环需要对每一对点进行处理，所以前面部分是O(N^2)。但是里层的排序，如果排序的复杂度是O(NlogN)时，那所有的点都在这个数组里，这个循环实际只会执行一次，这样的话总体复杂度就是O(N^2 * logN)。反之，如果很少有点在一条线上，那么排序的次数就会大大小于O(NlogN)，总的复杂度就是O(N^2)。综上，复杂度是O(N^2 * logN)
空间复杂度：O(N)，使用了字典存储数据，字典的大小和数组线性相关。N是数组的长度